<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZK XO - Zero-Knowledge Tic-Tac-Toe</title>
    <meta name="description" content="Play Zero-Knowledge XO (Tic-Tac-Toe) online! Commit and prove your moves without revealing them. Learn commitment schemes and ZK proofs in a classic game format.">
    <!-- Open Graph Meta Tags for SEO & Social Sharing -->
    <meta property="og:title" content="ZK XO - Zero Knowledge Tic-Tac-Toe">
    <meta property="og:description" content="Play Zero-Knowledge XO (Tic-Tac-Toe) online! Commit and prove your moves without revealing them. Learn commitment schemes and ZK proofs in a classic game format.">
    <meta property="og:image" content="images/games/zk_xo.png">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://sp1-gaming-hub.vercel.app/zk_xo_game.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ZK XO - Zero Knowledge Tic-Tac-Toe">
    <meta name="twitter:description" content="Play Zero-Knowledge XO (Tic-Tac-Toe) online! Commit and prove your moves without revealing them. Learn commitment schemes and ZK proofs in a classic game format.">
    <meta name="twitter:image" content="images/games/zk_xo.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --accent: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --dark: #0f172a;
            --dark-lighter: #1e293b;
            --dark-card: #334155;
            --text: #e2e8f0;
            --text-dim: #94a3b8;
            --border: #475569;
            --player-x: #ef4444;
            --player-o: #10b981;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--dark);
            color: var(--text);
            min-height: 100vh;
            padding-top: 80px;
        }

        /* Navigation */
        .nav-header {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
        }

        .nav-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            background-clip: text;
-webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-link {
            color: var(--text-dim);
            text-decoration: none;
            transition: color 0.3s;
        }

        .nav-link:hover {
            color: var(--text);
        }

        /* Animated Background */
        .grid-bg {
            position: fixed;
            inset: 0;
            z-index: -1;
            opacity: 0.02;
            background-image: 
                linear-gradient(90deg, var(--primary) 1px, transparent 1px),
                linear-gradient(var(--primary) 1px, transparent 1px);
            background-size: 40px 40px;
            animation: gridMove 30s linear infinite;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(40px, 40px); }
        }

        /* Main Container */
        .game-container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 3rem;
            align-items: start;
        }

        /* Header */
        .game-header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 3rem;
        }

        .game-title {
            font-size: 3.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            background-clip: text;
-webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .game-subtitle {
            font-size: 1.3rem;
            color: var(--text-dim);
            margin-bottom: 2rem;
        }

        /* Game Modes */
        .game-modes {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
        }

        .mode-btn {
            padding: 1rem 2rem;
            background: var(--dark-card);
            border: 2px solid var(--border);
            border-radius: 0.75rem;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
            font-weight: 500;
        }

        .mode-btn.active {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--primary);
            color: var(--primary);
        }

        .mode-btn:hover:not(.active) {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        /* Main Game Area */
        .game-board-container {
            background: var(--dark-lighter);
            border: 2px solid var(--border);
            border-radius: 1.5rem;
            padding: 3rem;
            position: relative;
        }

        /* Player Status */
        .player-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--dark-card);
            border-radius: 1rem;
            border: 2px solid var(--border);
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            border: 3px solid;
        }

        .player-x {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--player-x);
            color: var(--player-x);
        }

        .player-o {
            background: rgba(16, 185, 129, 0.2);
            border-color: var(--player-o);
            color: var(--player-o);
        }

        .player-details h3 {
            margin-bottom: 0.25rem;
            font-size: 1.1rem;
        }

        .player-score {
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .current-turn {
            animation: pulse 2s infinite;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Turn Indicator */
        .turn-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            font-weight: 600;
            border: 2px solid var(--border);
        }

        .turn-x {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--player-x);
            color: var(--player-x);
        }

        .turn-o {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--player-o);
            color: var(--player-o);
        }

        /* Game Board */
        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            max-width: 400px;
            margin: 0 auto 2rem;
            background: var(--dark);
            padding: 8px;
            border-radius: 1rem;
            position: relative;
        }

        .cell {
            aspect-ratio: 1;
            background: var(--dark-card);
            border: 2px solid var(--border);
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .cell:hover:not(.occupied) {
            background: rgba(99, 102, 241, 0.1);
            border-color: var(--primary);
            transform: scale(1.05);
        }

        .cell.occupied {
            cursor: default;
        }

        .cell.x {
            color: var(--player-x);
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--player-x);
        }

        .cell.o {
            color: var(--player-o);
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--player-o);
        }

        .cell.winning {
            animation: winPulse 1s ease infinite;
        }

        @keyframes winPulse {
            0%, 100% { 
                background: rgba(99, 102, 241, 0.2);
                transform: scale(1);
            }
            50% { 
                background: rgba(99, 102, 241, 0.4);
                transform: scale(1.1);
            }
        }

        /* Move Preview */
        .cell.preview-x::before {
            content: '×';
            position: absolute;
            color: var(--player-x);
            opacity: 0.5;
            font-size: 4rem;
        }

        .cell.preview-o::before {
            content: '○';
            position: absolute;
            color: var(--player-o);
            opacity: 0.5;
            font-size: 4rem;
        }

        /* ZK Proof Section */
        .zk-proof-section {
            background: var(--dark-card);
            border: 2px solid var(--border);
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .proof-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .proof-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--dark);
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }

        .proof-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-dim);
        }

        .proof-indicator.generating {
            background: var(--warning);
            animation: pulse 1.5s infinite;
        }

        .proof-indicator.verified {
            background: var(--accent);
        }

        .proof-indicator.invalid {
            background: var(--error);
        }

        .move-commitment {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .commitment-item {
            padding: 1rem;
            background: var(--dark);
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }

        .commitment-label {
            font-size: 0.875rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
        }

        .commitment-value {
            font-family: monospace;
            font-size: 0.875rem;
            color: var(--primary);
        }

        /* Control Buttons */
        .control-section {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.75rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover:not(:disabled) {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Side Panel */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .info-card {
            background: var(--dark-lighter);
            border: 2px solid var(--border);
            border-radius: 1.5rem;
            padding: 2rem;
        }

        .info-card h3 {
            margin-bottom: 1.5rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.3rem;
        }

        /* Game Statistics */
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: var(--text-dim);
            font-size: 0.95rem;
        }

        .stat-value {
            font-weight: 600;
            color: var(--primary);
            font-size: 1.1rem;
        }

        /* ZK Concepts */
        .zk-concept {
            background: var(--dark-card);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border-left: 4px solid var(--primary);
        }

        .concept-title {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        .concept-description {
            color: var(--text-dim);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        /* Game Mode Descriptions */
        .mode-description {
            background: var(--dark-card);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .mode-title {
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 0.75rem;
        }

        .mode-features {
            list-style: none;
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .mode-features li {
            padding: 0.25rem 0;
            padding-left: 1.5rem;
            position: relative;
        }

        .mode-features li::before {
            content: '→';
            position: absolute;
            left: 0;
            color: var(--accent);
        }

        /* Success Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 2rem;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--dark-lighter);
            border: 2px solid var(--accent);
            border-radius: 1.5rem;
            padding: 3rem;
            text-align: center;
            max-width: 500px;
            animation: modalSlide 0.3s ease;
            position: relative;
        }

        @keyframes modalSlide {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .winner-icon {
            font-size: 5rem;
            margin-bottom: 1rem;
            animation: bounce 1s ease infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        /* Player Selection */
        .player-selection {
            background: var(--dark-card);
            border: 2px solid var(--border);
            border-radius: 1rem;
            padding: 3rem 2rem;
            margin-bottom: 2rem;
        }

        .symbol-btn {
            background: var(--dark-lighter);
            border: 3px solid var(--border);
            border-radius: 1rem;
            padding: 2rem 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-width: 150px;
        }

        .symbol-btn:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.2);
        }

        .symbol-icon {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .symbol-btn:hover .symbol-icon {
            color: var(--primary);
        }

        .symbol-label {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .symbol-note {
            font-size: 0.9rem;
            color: var(--text-dim);
        }

        /* AI Thinking */
        .ai-thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .ai-thinking.show {
            display: block;
        }

        .thinking-text {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .thinking-dots {
            font-size: 2rem;
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '⚡'; }
            40% { content: '⚡⚡'; }
            60% { content: '⚡⚡⚡'; }
            80%, 100% { content: '⚡'; }
        }

        /* Focus styles for accessibility */
        .cell:focus, .symbol-btn:focus, .mode-btn:focus, .btn:focus, #difficultySelect:focus {
            outline: 3px solid var(--accent);
            outline-offset: 2px;
            box-shadow: 0 0 0 3px rgba(16,185,129,0.4);
        }

        /* Mobile Responsive */
        @media (max-width: 968px) {
            .game-container {
                grid-template-columns: 1fr;
                padding: 0 1rem;
                gap: 2rem;
            }

            .game-title {
                font-size: 2.5rem;
            }

            .nav-links {
                display: none;
            }

            body {
                padding-top: 60px;
            }

            .game-container {
                margin: 1rem auto;
            }

            .game-modes {
                flex-direction: column;
                align-items: center;
            }

            .mode-btn {
                width: 100%;
                max-width: 300px;
            }

            .player-status {
                flex-direction: column;
                gap: 1rem;
            }

            .control-section {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 100%;
                max-width: 300px;
                justify-content: center;
            }
        }

        /* Loading Animation */
        .loader {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Confetti Effect */
        .confetti {
            position: fixed;
            width: 8px;
            height: 8px;
            background: var(--primary);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
        }
    </style>
    <link rel="stylesheet" href="css/zkhub-optimizations.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="nav-header">
        <div class="nav-content">
            <a href="/index.html" class="logo">
                <span>🎮</span>
                <span>ZK Gaming Hub</span>
            </a>
            <div class="nav-links">
                <a href="/index.html" class="nav-link">Home</a>
                <a href="/games.html" class="nav-link">Games</a>
                <a href="games.html" class="nav-link">Games</a>
            </div>
        </div>
    </nav>

    <!-- Animated Background -->
    <div class="grid-bg"></div>

    <div class="game-container">
        <!-- Header -->
        <div class="game-header">
            <h1 class="game-title">
                <span>⚡</span>
                <span>ZK XO</span>
            </h1>
            <p class="game-subtitle">Zero-Knowledge Tic-Tac-Toe - Prove your moves without revealing strategy!</p>
            
            <!-- Game Modes -->
            <div class="game-modes">
                <button class="mode-btn active" onclick="setGameMode('classic')" data-mode="classic">
                    🎯 Classic Mode
                </button>
                <button class="mode-btn" onclick="setGameMode('commitment')" data-mode="commitment">
                    🔐 Commitment Mode
                </button>
                <button class="mode-btn" onclick="setGameMode('hidden')" data-mode="hidden">
                    👁️ Hidden Mode
                </button>
            </div>
        </div>

        <!-- Main Game Area -->
        <div class="game-board-container">
            <!-- Player Selection -->
            <div class="player-selection" id="playerSelection">
                <h3 style="text-align: center; margin-bottom: 1.5rem; color: var(--primary);">Choose Your Symbol</h3>
                <div style="display: flex; gap: 2rem; justify-content: center;">
                    <button class="symbol-btn" onclick="selectPlayerSymbol('X')" tabindex="0" aria-label="Select X as your symbol"> 
                        <div class="symbol-icon">×</div>
                        <div class="symbol-label">Play as X</div>
                        <div class="symbol-note">You go first</div>
                    </button>
                    <button class="symbol-btn" onclick="selectPlayerSymbol('O')" tabindex="0" aria-label="Select O as your symbol">
                        <div class="symbol-icon">○</div>
                        <div class="symbol-label">Play as O</div>
                        <div class="symbol-note">AI goes first</div>
                    </button>
                </div>
            </div>

            <!-- Player Status -->
            <div class="player-status" id="gameStatus" style="display: none;">
                <div class="player-info">
                    <div class="player-avatar" id="humanAvatar">👤</div>
                    <div class="player-details">
                        <h3 id="humanLabel">You</h3>
                        <div class="player-score">Wins: <span id="humanScore">0</span></div>
                    </div>
                </div>
                
                <div class="turn-indicator" id="turnIndicator" aria-live="polite">
                    <div class="turn-text">Your Turn</div>
                </div>
                
                <div class="player-info">
                    <div class="player-avatar" id="aiAvatar">🤖</div>
                    <div class="player-details">
                        <h3>ZK Bot</h3>
                        <div class="player-score">Wins: <span id="aiScore">0</span></div>
                    </div>
                </div>
            </div>

            <!-- Game Board -->
            <div class="game-board" id="gameBoard">
                <div class="cell" data-index="0" onclick="makeMove(0)" tabindex="0" role="button" aria-label="Cell 1" onkeydown="if(event.key==='Enter'||event.key===' '){makeMove(0);}"></div>
                <div class="cell" data-index="1" onclick="makeMove(1)" tabindex="0" role="button" aria-label="Cell 2" onkeydown="if(event.key==='Enter'||event.key===' '){makeMove(1);}"></div>
                <div class="cell" data-index="2" onclick="makeMove(2)" tabindex="0" role="button" aria-label="Cell 3" onkeydown="if(event.key==='Enter'||event.key===' '){makeMove(2);}"></div>
                <div class="cell" data-index="3" onclick="makeMove(3)" tabindex="0" role="button" aria-label="Cell 4" onkeydown="if(event.key==='Enter'||event.key===' '){makeMove(3);}"></div>
                <div class="cell" data-index="4" onclick="makeMove(4)" tabindex="0" role="button" aria-label="Cell 5" onkeydown="if(event.key==='Enter'||event.key===' '){makeMove(4);}"></div>
                <div class="cell" data-index="5" onclick="makeMove(5)" tabindex="0" role="button" aria-label="Cell 6" onkeydown="if(event.key==='Enter'||event.key===' '){makeMove(5);}"></div>
                <div class="cell" data-index="6" onclick="makeMove(6)" tabindex="0" role="button" aria-label="Cell 7" onkeydown="if(event.key==='Enter'||event.key===' '){makeMove(6);}"></div>
                <div class="cell" data-index="7" onclick="makeMove(7)" tabindex="0" role="button" aria-label="Cell 8" onkeydown="if(event.key==='Enter'||event.key===' '){makeMove(7);}"></div>
                <div class="cell" data-index="8" onclick="makeMove(8)" tabindex="0" role="button" aria-label="Cell 9" onkeydown="if(event.key==='Enter'||event.key===' '){makeMove(8);}"></div>
            </div>

            <!-- Difficulty Selector -->
            <div style="text-align: center; margin-bottom: 2rem;">
                <label style="color: var(--text-dim); margin-right: 1rem;">AI Difficulty:</label>
                <select id="difficultySelect" onchange="changeDifficulty()" aria-label="Select AI difficulty" style="padding: 0.5rem; background: var(--dark-card); color: var(--text); border: 1px solid var(--border); border-radius: 0.5rem;">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                </select>
            </div>

            <!-- ZK Proof Section -->
            <div class="zk-proof-section">
                <div class="proof-header">
                    <h3>🔐 Zero-Knowledge Proof</h3>
                    <div class="proof-status">
                        <div class="proof-indicator" id="proofIndicator"></div>
                        <span id="proofStatusText">Ready to generate proof</span>
                    </div>
                </div>

                <div class="move-commitment" id="commitmentSection">
                    <div class="commitment-item">
                        <div class="commitment-label">Move Commitment</div>
                        <div class="commitment-value" id="commitmentHash">--</div>
                    </div>
                    <div class="commitment-item">
                        <div class="commitment-label">Proof Hash</div>
                        <div class="commitment-value" id="proofHash">--</div>
                    </div>
                </div>
            </div>

            <!-- Control Section -->
            <div class="control-section">
                <button class="btn btn-secondary" onclick="newGame()">
                    <span>🔄</span>
                    <span>New Game</span>
                </button>
                <button class="btn btn-primary" onclick="generateProof()" id="proofBtn" disabled>
                    <span>⚡</span>
                    <span>Generate Proof</span>
                </button>
                <button class="btn btn-secondary" onclick="showHint()">
                    <span>💡</span>
                    <span>Hint</span>
                </button>
            </div>
        </div>

        <!-- Side Panel -->
        <div class="side-panel">
            <!-- Game Statistics -->
            <div class="info-card">
                <h3>📊 Game Statistics</h3>
                <div class="stat-row">
                    <span class="stat-label">Total Games</span>
                    <span class="stat-value" id="totalGames">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Current Streak</span>
                    <span class="stat-value" id="currentStreak">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Best Streak</span>
                    <span class="stat-value" id="bestStreak">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Proofs Generated</span>
                    <span class="stat-value" id="proofsGenerated">0</span>
                </div>
            </div>

            <!-- ZK Concepts -->
            <div class="info-card">
                <h3>🧠 ZK Concepts</h3>
                
                <div class="zk-concept">
                    <div class="concept-title">Commitment Schemes</div>
                    <div class="concept-description">
                        Commit to your move without revealing it. Like putting your choice in a sealed envelope.
                    </div>
                </div>

                <div class="zk-concept">
                    <div class="concept-title">Move Verification</div>
                    <div class="concept-description">
                        Prove your move is valid without showing your entire strategy or future plans.
                    </div>
                </div>

                <div class="zk-concept">
                    <div class="concept-title">Game State Proofs</div>
                    <div class="concept-description">
                        Verify the current game state is correct without revealing hidden information.
                    </div>
                </div>
            </div>

            <!-- Game Modes Info -->
            <div class="info-card" id="modeInfo">
                <h3>🎮 Current Mode</h3>
                
                <div class="mode-description" id="modeDescription">
                    <div class="mode-title">Classic Mode</div>
                    <ul class="mode-features">
                        <li>Traditional tic-tac-toe gameplay</li>
                        <li>Learn basic ZK proof concepts</li>
                        <li>Perfect for beginners</li>
                        <li>Real-time move verification</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal" role="dialog" aria-modal="true" aria-labelledby="gameResultTitle" aria-describedby="gameResultDescription">
        <div class="modal-content">
            <div class="winner-icon" id="winnerIcon">🏆</div>
            <h2 style="font-size: 2.5rem; margin-bottom: 1rem;" id="gameResultTitle">Player X Wins!</h2>
            <p style="color: var(--text-dim); margin-bottom: 2rem;" id="gameResultDescription">
                Congratulations! You've successfully generated a Zero-Knowledge proof of victory!
            </p>
            
            <div style="background: var(--dark); padding: 2rem; border-radius: 1rem; margin-bottom: 2rem;">
                <h4 style="color: var(--primary); margin-bottom: 1rem;">🔐 ZK Proof Summary</h4>
                <div style="text-align: left;">
                    <div class="stat-row">
                        <span class="stat-label">Moves Made</span>
                        <span class="stat-value" id="modalMoves">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Proof Complexity</span>
                        <span class="stat-value" id="modalComplexity">Medium</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">ZK Points Earned</span>
                        <span class="stat-value" style="color: var(--accent);" id="modalPoints">+50</span>
                    </div>
                </div>
            </div>

            <div style="display: flex; gap: 1rem; justify-content: center;">
                <button class="btn btn-secondary" onclick="closeModal()">
                    <span>📊</span>
                    <span>View Stats</span>
                </button>
                <button class="btn btn-primary" onclick="playAgain()">
                    <span>🎮</span>
                    <span>Play Again</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let gameState = {
            board: Array(9).fill(null),
            humanPlayer: null, // 'X' or 'O'
            aiPlayer: null,    // 'X' or 'O'
            currentPlayer: 'X',
            gameMode: 'classic',
            isGameOver: false,
            isAITurn: false,
            winner: null,
            winningLine: null,
            moveCount: 0,
            commitments: {},
            scores: {
                human: parseInt(localStorage.getItem('zk-xo-score-human') || '0'),
                ai: parseInt(localStorage.getItem('zk-xo-score-ai') || '0')
            },
            stats: {
                totalGames: parseInt(localStorage.getItem('zk-xo-total-games') || '0'),
                currentStreak: parseInt(localStorage.getItem('zk-xo-current-streak') || '0'),
                bestStreak: parseInt(localStorage.getItem('zk-xo-best-streak') || '0'),
                proofsGenerated: parseInt(localStorage.getItem('zk-xo-proofs') || '0')
            }
        };

        // AI difficulty levels
        const aiDifficulty = {
            easy: 0.3,    // 30% chance of optimal move
            medium: 0.7,  // 70% chance of optimal move
            hard: 0.95    // 95% chance of optimal move
        };

        let currentDifficulty = 'medium';

        // Winning combinations
        const winningCombinations = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6] // Diagonals
        ];

        // Game Mode Configurations
        const gameModes = {
            classic: {
                name: 'Classic Mode',
                description: 'Traditional tic-tac-toe vs AI',
                features: [
                    'Traditional tic-tac-toe vs AI',
                    'Learn basic ZK proof concepts',
                    'Perfect for beginners',
                    'Real-time move verification'
                ]
            },
            commitment: {
                name: 'Commitment Mode',
                description: 'Commit to moves before revealing',
                features: [
                    'Commit to your move first',
                    'AI commits simultaneously',
                    'Learn commitment schemes',
                    'Prevents strategy copying'
                ]
            },
            hidden: {
                name: 'Hidden Mode',
                description: 'Moves are hidden until verification',
                features: [
                    'Moves remain hidden',
                    'Generate proofs of valid moves',
                    'Advanced ZK concepts',
                    'Ultimate privacy protection'
                ]
            }
        };

        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            updateStats();
            updateScores();
            updateModeDescription();
            showPlayerSelection();
            addCellHoverEffects();
        });

        // Global functions that need to be accessible from HTML onclick attributes
        window.makeMove = makeMove;
        window.newGame = newGame;
        window.generateProof = generateProof;
        window.showHint = showHint;
        window.setGameMode = setGameMode;
        window.selectPlayerSymbol = selectPlayerSymbol;
        window.changeDifficulty = changeDifficulty;
        window.closeModal = closeModal;
        window.playAgain = playAgain;

        function showPlayerSelection() {
            document.getElementById('playerSelection').style.display = 'block';
            document.getElementById('gameStatus').style.display = 'none';
            document.getElementById('gameBoard').style.opacity = '0.3';
            document.getElementById('gameBoard').style.pointerEvents = 'none';
        }

        function selectPlayerSymbol(symbol) {
            gameState.humanPlayer = symbol;
            gameState.aiPlayer = symbol === 'X' ? 'O' : 'X';
            
            // Update UI
            document.getElementById('playerSelection').style.display = 'none';
            document.getElementById('gameStatus').style.display = 'flex';
            document.getElementById('gameBoard').style.opacity = '1';
            document.getElementById('gameBoard').style.pointerEvents = 'auto';
            
            // Update avatars and labels
            const humanAvatar = document.getElementById('humanAvatar');
            const aiAvatar = document.getElementById('aiAvatar');
            
            humanAvatar.textContent = symbol;
            humanAvatar.className = `player-avatar ${symbol === 'X' ? 'player-x' : 'player-o'}`;
            
            aiAvatar.textContent = gameState.aiPlayer;
            aiAvatar.className = `player-avatar ${gameState.aiPlayer === 'X' ? 'player-x' : 'player-o'}`;
            
            // Start new game
            newGame();
            
            // If AI goes first (human chose O), make AI move
            if (gameState.aiPlayer === 'X') {
                setTimeout(() => makeAIMove(), 1000);
            }
        }

        function makeMove(index) {
            if (gameState.isGameOver || gameState.board[index] !== null || gameState.isAITurn) return;
            if (gameState.currentPlayer !== gameState.humanPlayer) return;

            // Handle different game modes
            switch (gameState.gameMode) {
                case 'classic':
                    makeClassicMove(index);
                    break;
                case 'commitment':
                    makeCommitmentMove(index);
                    break;
                case 'hidden':
                    makeHiddenMove(index);
                    break;
            }
        }

        function makeClassicMove(index) {
            gameState.board[index] = gameState.currentPlayer;
            gameState.moveCount++;
            
            // Generate simple proof for the move
            generateMoveProof(index, gameState.currentPlayer);
            
            renderBoard();
            
            const winner = checkWinner();
            if (winner) {
                gameOver(winner);
            } else if (gameState.moveCount === 9) {
                gameOver('tie');
            } else {
                switchPlayer();
                
                // Make AI move if it's AI's turn
                if (gameState.currentPlayer === gameState.aiPlayer) {
                    setTimeout(() => makeAIMove(), 800);
                }
            }
        }

        function makeCommitmentMove(index) {
            // For now, same as classic but with commitment hash generation
            makeClassicMove(index);
            const commitmentHash = generateCommitmentHash(index, gameState.currentPlayer);
            document.getElementById('commitmentHash').textContent = commitmentHash;
        }

        function makeHiddenMove(index) {
            // For now, same as classic but with hidden state indicators
            makeClassicMove(index);
        }

        function makeAIMove() {
            if (gameState.isGameOver || gameState.currentPlayer !== gameState.aiPlayer) return;
            
            gameState.isAITurn = true;
            showAIThinking();
            
            // Calculate AI move based on difficulty
            const moveIndex = calculateAIMove();
            
            setTimeout(() => {
                hideAIThinking();
                
                if (moveIndex !== -1) {
                    gameState.board[moveIndex] = gameState.aiPlayer;
                    gameState.moveCount++;
                    
                    // Generate proof for AI move
                    generateMoveProof(moveIndex, gameState.aiPlayer);
                    
                    renderBoard();
                    
                    const winner = checkWinner();
                    if (winner) {
                        gameOver(winner);
                    } else if (gameState.moveCount === 9) {
                        gameOver('tie');
                    } else {
                        switchPlayer();
                    }
                }
                
                gameState.isAITurn = false;
            }, Math.random() * 1000 + 500); // Random thinking time
        }

        function calculateAIMove() {
            // Get available moves
            const availableMoves = gameState.board
                .map((cell, index) => cell === null ? index : null)
                .filter(index => index !== null);
            
            if (availableMoves.length === 0) return -1;
            
            // Check if AI should play optimally based on difficulty
            const shouldPlayOptimal = Math.random() < aiDifficulty[currentDifficulty];
            
            if (shouldPlayOptimal) {
                // Try to win first
                for (const move of availableMoves) {
                    const testBoard = [...gameState.board];
                    testBoard[move] = gameState.aiPlayer;
                    if (checkWinnerForBoard(testBoard) === gameState.aiPlayer) {
                        return move;
                    }
                }
                
                // Block human from winning
                for (const move of availableMoves) {
                    const testBoard = [...gameState.board];
                    testBoard[move] = gameState.humanPlayer;
                    if (checkWinnerForBoard(testBoard) === gameState.humanPlayer) {
                        return move;
                    }
                }
                
                // Take center if available
                if (availableMoves.includes(4)) {
                    return 4;
                }
                
                // Take corners
                const corners = [0, 2, 6, 8].filter(corner => availableMoves.includes(corner));
                if (corners.length > 0) {
                    return corners[Math.floor(Math.random() * corners.length)];
                }
                
                // Take any available move
                return availableMoves[Math.floor(Math.random() * availableMoves.length)];
            } else {
                // Play randomly (easier difficulty)
                return availableMoves[Math.floor(Math.random() * availableMoves.length)];
            }
        }

        function checkWinnerForBoard(board) {
            for (const combination of winningCombinations) {
                const [a, b, c] = combination;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a];
                }
            }
            return null;
        }

        function showAIThinking() {
            const thinkingDiv = document.createElement('div');
            thinkingDiv.id = 'aiThinking';
            thinkingDiv.className = 'ai-thinking show';
            thinkingDiv.innerHTML = `
                <div class="thinking-text">🤖 ZK Bot is thinking...</div>
                <div class="thinking-dots">⚡</div>
            `;
            document.body.appendChild(thinkingDiv);
        }

        function hideAIThinking() {
            const thinkingDiv = document.getElementById('aiThinking');
            if (thinkingDiv) {
                thinkingDiv.remove();
            }
        }

        function switchPlayer() {
            gameState.currentPlayer = gameState.currentPlayer === 'X' ? 'O' : 'X';
            updateTurnIndicator();
        }

        function updateTurnIndicator() {
            const turnIndicator = document.getElementById('turnIndicator');
            const humanAvatar = document.getElementById('humanAvatar');
            const aiAvatar = document.getElementById('aiAvatar');
            
            if (gameState.currentPlayer === gameState.humanPlayer) {
                turnIndicator.className = `turn-indicator turn-${gameState.humanPlayer.toLowerCase()}`;
                turnIndicator.querySelector('.turn-text').textContent = 'Your Turn';
                humanAvatar.classList.add('current-turn');
                aiAvatar.classList.remove('current-turn');
            } else {
                turnIndicator.className = `turn-indicator turn-${gameState.aiPlayer.toLowerCase()}`;
                turnIndicator.querySelector('.turn-text').textContent = 'AI Turn';
                aiAvatar.classList.add('current-turn');
                humanAvatar.classList.remove('current-turn');
            }
        }

        function gameOver(result) {
            gameState.isGameOver = true;
            gameState.winner = result;
            gameState.isAITurn = false;
            
            // Update statistics
            gameState.stats.totalGames++;
            
            if (result === gameState.humanPlayer) {
                gameState.scores.human++;
                gameState.stats.currentStreak++;
                gameState.stats.bestStreak = Math.max(gameState.stats.bestStreak, gameState.stats.currentStreak);
            } else if (result === gameState.aiPlayer) {
                gameState.scores.ai++;
                gameState.stats.currentStreak = 0;
            } else {
                gameState.stats.currentStreak = 0;
            }
            
            // Highlight winning line
            if (gameState.winningLine) {
                gameState.winningLine.forEach(index => {
                    const cell = document.querySelector(`[data-index="${index}"]`);
                    if (cell) cell.classList.add('winning');
                });
            }
            
            // Enable proof generation
            document.getElementById('proofBtn').disabled = false;
            
            saveGameData();
            updateStats();
            updateScores();
            
            // Show game over modal after a delay
            setTimeout(() => {
                showGameOverModal(result);
            }, 1500);
        }

        function checkWinner() {
            for (const combination of winningCombinations) {
                const [a, b, c] = combination;
                if (gameState.board[a] && 
                    gameState.board[a] === gameState.board[b] && 
                    gameState.board[a] === gameState.board[c]) {
                    gameState.winningLine = combination;
                    return gameState.board[a];
                }
            }
            return null;
        }

        function renderBoard() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cell, index) => {
                const value = gameState.board[index];
                cell.textContent = value || '';
                cell.className = 'cell';
                
                if (value) {
                    cell.classList.add('occupied', value.toLowerCase());
                }
            });
        }

        function addCellHoverEffects() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cell, index) => {
                cell.addEventListener('mouseenter', () => {
                    if (!gameState.isGameOver && !gameState.board[index] && !gameState.isAITurn && gameState.currentPlayer === gameState.humanPlayer) {
                        cell.classList.add(`preview-${gameState.humanPlayer.toLowerCase()}`);
                    }
                });
                
                cell.addEventListener('mouseleave', () => {
                    cell.classList.remove('preview-x', 'preview-o');
                });
            });
        }

        function changeDifficulty() {
            const select = document.getElementById('difficultySelect');
            currentDifficulty = select.value;
        }

        function setGameMode(mode) {
            gameState.gameMode = mode;
            
            // Update UI
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = document.querySelector(`[data-mode="${mode}"]`);
            if (activeBtn) activeBtn.classList.add('active');
            
            updateModeDescription();
            if (gameState.humanPlayer) {
                newGame();
            }
        }

        function updateModeDescription() {
            const modeDescription = document.getElementById('modeDescription');
            const mode = gameModes[gameState.gameMode];
            
            modeDescription.innerHTML = `
                <div class="mode-title">${mode.name}</div>
                <ul class="mode-features">
                    ${mode.features.map(feature => `<li>${feature}</li>`).join('')}
                </ul>
            `;
        }

        function generateMoveProof(index, player) {
            const proofIndicator = document.getElementById('proofIndicator');
            const proofStatusText = document.getElementById('proofStatusText');
            const proofHash = document.getElementById('proofHash');
            
            proofIndicator.className = 'proof-indicator generating';
            proofStatusText.textContent = 'Generating proof...';
            
            setTimeout(() => {
                const hash = generateProofHash(index, player, gameState.moveCount);
                proofHash.textContent = hash;
                
                proofIndicator.className = 'proof-indicator verified';
                proofStatusText.textContent = 'Move verified';
            }, 800);
        }

        function generateProofHash(index, player, nonce) {
            const data = `${index}_${player}_${nonce}_${Date.now()}`;
            let hash = 0;
            for (let i = 0; i < data.length; i++) {
                hash = ((hash << 5) - hash) + data.charCodeAt(i);
                hash = hash & hash;
            }
            return `0x${Math.abs(hash).toString(16).padStart(8, '0').substr(0, 8)}`;
        }

        function generateCommitmentHash(index, player) {
            const nonce = Math.random().toString(36).substr(2, 9);
            const data = `${index}_${player}_${nonce}`;
            let hash = 0;
            for (let i = 0; i < data.length; i++) {
                hash = ((hash << 5) - hash) + data.charCodeAt(i);
                hash = hash & hash;
            }
            return `0x${Math.abs(hash).toString(16).padStart(8, '0').substr(0, 8)}`;
        }

        function generateProof() {
            if (!gameState.isGameOver) return;
            
            const btn = document.getElementById('proofBtn');
            btn.innerHTML = '<span class="loader"></span><span>Generating...</span>';
            btn.disabled = true;
            
            gameState.stats.proofsGenerated++;
            
            setTimeout(() => {
                const proofHash = generateProofHash(gameState.winner, 'final', gameState.moveCount);
                document.getElementById('proofHash').textContent = proofHash;
                
                document.getElementById('proofIndicator').className = 'proof-indicator verified';
                document.getElementById('proofStatusText').textContent = 'Game proof verified!';
                
                btn.innerHTML = '<span>⚡</span><span>Generate Proof</span>';
                
                saveGameData();
                updateStats();
                
                // Show success animation
                createConfetti();
            }, 2000);
        }

        function showHint() {
            if (gameState.isGameOver || gameState.isAITurn || gameState.currentPlayer !== gameState.humanPlayer) return;
            
            // Find best move for human player
            const bestMove = findBestMoveForHuman();
            if (bestMove !== -1) {
                const cell = document.querySelector(`[data-index="${bestMove}"]`);
                if (cell) {
                    cell.style.background = 'rgba(245, 158, 11, 0.3)';
                    cell.style.borderColor = 'var(--warning)';
                    
                    setTimeout(() => {
                        cell.style.background = '';
                        cell.style.borderColor = '';
                    }, 2000);
                }
            }
        }

        function findBestMoveForHuman() {
            const availableMoves = gameState.board
                .map((cell, index) => cell === null ? index : null)
                .filter(index => index !== null);
            
            if (availableMoves.length === 0) return -1;
            
            // Try to win first
            for (const move of availableMoves) {
                const testBoard = [...gameState.board];
                testBoard[move] = gameState.humanPlayer;
                if (checkWinnerForBoard(testBoard) === gameState.humanPlayer) {
                    return move;
                }
            }
            
            // Block AI from winning
            for (const move of availableMoves) {
                const testBoard = [...gameState.board];
                testBoard[move] = gameState.aiPlayer;
                if (checkWinnerForBoard(testBoard) === gameState.aiPlayer) {
                    return move;
                }
            }
            
            // Take center if available
            if (availableMoves.includes(4)) {
                return 4;
            }
            
            // Take corners
            const corners = [0, 2, 6, 8].filter(corner => availableMoves.includes(corner));
            if (corners.length > 0) {
                return corners[0];
            }
            
            // Take any available move
            return availableMoves[0];
        }

        function newGame() {
            gameState.board = Array(9).fill(null);
            gameState.currentPlayer = 'X';
            gameState.isGameOver = false;
            gameState.isAITurn = false;
            gameState.winner = null;
            gameState.winningLine = null;
            gameState.moveCount = 0;
            gameState.commitments = {};
            
            // Reset UI
            document.getElementById('proofBtn').disabled = true;
            document.getElementById('proofIndicator').className = 'proof-indicator';
            document.getElementById('proofStatusText').textContent = 'Ready to generate proof';
            document.getElementById('commitmentHash').textContent = '--';
            document.getElementById('proofHash').textContent = '--';
            
            renderBoard();
            updateTurnIndicator();
            
            // Close modal if open
            document.getElementById('gameOverModal').classList.remove('show');
            
            // Remove any AI thinking indicator
            hideAIThinking();
        }

        function updateStats() {
            document.getElementById('totalGames').textContent = gameState.stats.totalGames;
            document.getElementById('currentStreak').textContent = gameState.stats.currentStreak;
            document.getElementById('bestStreak').textContent = gameState.stats.bestStreak;
            document.getElementById('proofsGenerated').textContent = gameState.stats.proofsGenerated;
        }

        function updateScores() {
            document.getElementById('humanScore').textContent = gameState.scores.human;
            document.getElementById('aiScore').textContent = gameState.scores.ai;
        }

        function saveGameData() {
            try {
                localStorage.setItem('zk-xo-score-human', gameState.scores.human.toString());
                localStorage.setItem('zk-xo-score-ai', gameState.scores.ai.toString());
                localStorage.setItem('zk-xo-total-games', gameState.stats.totalGames.toString());
                localStorage.setItem('zk-xo-current-streak', gameState.stats.currentStreak.toString());
                localStorage.setItem('zk-xo-best-streak', gameState.stats.bestStreak.toString());
                localStorage.setItem('zk-xo-proofs', gameState.stats.proofsGenerated.toString());
            } catch (error) {
                console.warn('Failed to save game data:', error);
            }
        }

        function showGameOverModal(result) {
            const modal = document.getElementById('gameOverModal');
            const winnerIcon = document.getElementById('winnerIcon');
            const gameResultTitle = document.getElementById('gameResultTitle');
            const gameResultDescription = document.getElementById('gameResultDescription');
            
            if (result === 'tie') {
                winnerIcon.textContent = '🤝';
                gameResultTitle.textContent = "It's a Tie!";
                gameResultDescription.textContent = "Great game! You matched the ZK Bot's strategy.";
            } else if (result === gameState.humanPlayer) {
                winnerIcon.textContent = result === 'X' ? '❌' : '⭕';
                gameResultTitle.textContent = `You Win!`;
                gameResultDescription.textContent = "Congratulations! You've outsmarted the ZK Bot and generated a proof of victory!";
            } else {
                winnerIcon.textContent = result === 'X' ? '❌' : '⭕';
                gameResultTitle.textContent = `ZK Bot Wins!`;
                gameResultDescription.textContent = "The AI proved superior this time. Better luck next round!";
            }
            
            // Update modal stats
            document.getElementById('modalMoves').textContent = gameState.moveCount;
            document.getElementById('modalComplexity').textContent = getComplexityRating();
            document.getElementById('modalPoints').textContent = `+${calculatePoints()}`;
            
            modal.classList.add('show');
        }

        function getComplexityRating() {
            if (gameState.moveCount <= 5) return 'Simple';
            if (gameState.moveCount <= 7) return 'Medium';
            return 'Complex';
        }

        function calculatePoints() {
            let points = 10; // Base points
            
            // Game mode bonus
            if (gameState.gameMode === 'commitment') points += 20;
            if (gameState.gameMode === 'hidden') points += 30;
            
            // Move efficiency bonus
            if (gameState.moveCount <= 5) points += 15;
            
            // Win bonus
            if (gameState.winner === gameState.humanPlayer) points += 25;
            
            // Difficulty bonus
            if (currentDifficulty === 'medium') points += 10;
            if (currentDifficulty === 'hard') points += 20;
            
            return points;
        }

        function createConfetti() {
            const colors = ['#6366f1', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.top = '-10px';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 2 + 's';
                
                document.body.appendChild(confetti);
                
                // Animate falling
                let pos = -10;
                const fall = setInterval(() => {
                    pos += 3 + Math.random() * 2;
                    confetti.style.top = pos + 'px';
                    confetti.style.transform = `rotate(${pos * 2}deg)`;
                    
                    if (pos > window.innerHeight) {
                        clearInterval(fall);
                        confetti.remove();
                    }
                }, 20);
            }
        }

        function closeModal() {
            document.getElementById('gameOverModal').classList.remove('show');
        }

        function playAgain() {
            closeModal();
            setTimeout(() => {
                showPlayerSelection();
            }, 200);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key >= '1' && e.key <= '9') {
                const index = parseInt(e.key) - 1;
                makeMove(index);
            } else if (e.key === 'r' || e.key === 'R') {
                showPlayerSelection();
            } else if (e.key === 'h' || e.key === 'H') {
                showHint();
            } else if (e.key === 'p' || e.key === 'P') {
                if (!document.getElementById('proofBtn').disabled) {
                    generateProof();
                }
            }
        });

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                closeModal();
            }
        });

        // Enhanced error handling
        window.addEventListener('error', (e) => {
            console.error('ZK XO error:', e.error);
            try {
                if (gameState.board.some(cell => cell !== null && cell !== 'X' && cell !== 'O')) {
                    newGame();
                }
            } catch (resetError) {
                console.error('Failed to reset game after error:', resetError);
            }
        });

        console.log('⚡ ZK XO loaded successfully!');
        console.log('Controls: Click cells or use keys 1-9, R to restart, H for hint, P for proof');
    </script>
    <script src="js/zkhub-optimizations.js"></script>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
          navigator.serviceWorker.register('/sw.js').then(function(registration) {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
          }, function(err) {
            console.log('ServiceWorker registration failed: ', err);
          });
        });
      }
    </script>
</body>
</html>