<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZK Flow State - Connect the Proof Path</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --accent: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --dark: #0f172a;
            --dark-lighter: #1e293b;
            --dark-card: #334155;
            --text: #e2e8f0;
            --text-dim: #94a3b8;
            --border: #475569;
            --prover: #1bbd7e;
            --verifier: #e6c700;
            --flow: #6366f1;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--dark);
            color: var(--text);
            min-height: 100vh;
            padding-top: 80px;
        }

        /* Navigation */
        .nav-header {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
        }

        .nav-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-link {
            color: var(--text-dim);
            text-decoration: none;
            transition: color 0.3s;
        }

        .nav-link:hover {
            color: var(--text);
        }

        /* Animated Background */
        .circuit-bg {
            position: fixed;
            inset: 0;
            z-index: -1;
            opacity: 0.03;
            background-image: 
                linear-gradient(90deg, var(--primary) 1px, transparent 1px),
                linear-gradient(var(--primary) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: circuitMove 20s linear infinite;
        }

        @keyframes circuitMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Main Container */
        .game-container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 2rem;
            align-items: start;
        }

        /* Header */
        .game-header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 2rem;
        }

        .game-title {
            font-size: 3rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .game-subtitle {
            font-size: 1.2rem;
            color: var(--text-dim);
        }

        /* Game Board Container */
        .game-board-container {
            background: var(--dark-lighter);
            border: 2px solid var(--border);
            border-radius: 1rem;
            padding: 2rem;
            position: relative;
        }

        .level-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem;
            background: var(--dark-card);
            border-radius: 0.5rem;
        }

        .level-stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .stat-value {
            font-weight: 600;
            color: var(--primary);
        }

        /* Game Board */
        .game-board {
            display: grid;
            grid-template-columns: repeat(var(--board-size, 6), 1fr);
            gap: 4px;
            max-width: 600px;
            margin: 0 auto;
            background: var(--dark);
            border-radius: 1rem;
            padding: 1rem;
            position: relative;
        }

        .tile {
            aspect-ratio: 1;
            background: var(--dark-card);
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .tile:hover:not(.locked) {
            background: rgba(99, 102, 241, 0.1);
            border-color: var(--primary);
            transform: scale(1.05);
        }

        .tile.locked {
            cursor: default;
        }

        .tile.prover {
            background: var(--prover);
            border-color: var(--prover);
            animation: pulse 2s infinite;
        }

        .tile.verifier {
            background: var(--verifier);
            border-color: var(--verifier);
            animation: pulse 2s infinite;
        }

        .tile.flowing {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--flow);
            animation: flowPulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes flowPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.7);
            }
            50% { 
                box-shadow: 0 0 20px 5px rgba(99, 102, 241, 0.3);
            }
        }

        /* Pipe SVGs */
        .pipe-svg {
            width: 80%;
            height: 80%;
            transition: transform 0.3s;
        }

        .pipe-straight {
            fill: none;
            stroke: var(--text);
            stroke-width: 4;
            stroke-linecap: round;
        }

        .pipe-curve {
            fill: none;
            stroke: var(--text);
            stroke-width: 4;
            stroke-linecap: round;
        }

        .tile.flowing .pipe-straight,
        .tile.flowing .pipe-curve {
            stroke: var(--flow);
            filter: drop-shadow(0 0 8px var(--flow));
        }

        /* Control Panel */
        .control-panel {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        /* Side Panel */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .info-card {
            background: var(--dark-lighter);
            border: 2px solid var(--border);
            border-radius: 1rem;
            padding: 1.5rem;
        }

        .info-card h3 {
            margin-bottom: 1rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Status Display */
        .status-display {
            text-align: center;
            padding: 1rem;
            background: var(--dark-card);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            border: 2px solid var(--border);
        }

        .status-display.success {
            border-color: var(--accent);
            background: rgba(16, 185, 129, 0.1);
        }

        .status-display.waiting {
            border-color: var(--warning);
            background: rgba(245, 158, 11, 0.1);
        }

        .status-message {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .proof-status {
            font-size: 0.9rem;
            color: var(--text-dim);
        }

        /* Difficulty Selector */
        .difficulty-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .difficulty-btn {
            padding: 0.5rem 1rem;
            background: var(--dark-card);
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text);
        }

        .difficulty-btn.active {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--primary);
        }

        /* Pipe Instruction */
        .pipe-legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .pipe-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--dark-card);
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }

        .pipe-icon {
            width: 24px;
            height: 24px;
        }

        /* Success Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 2rem;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--dark-lighter);
            border: 2px solid var(--accent);
            border-radius: 1rem;
            padding: 3rem;
            text-align: center;
            max-width: 500px;
            animation: modalSlide 0.3s ease;
        }

        @keyframes modalSlide {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
                padding: 0 1rem;
            }

            .game-title {
                font-size: 2rem;
            }

            .nav-links {
                display: none;
            }

            body {
                padding-top: 60px;
            }

            .game-container {
                margin: 1rem auto;
            }

            .level-stats {
                flex-wrap: wrap;
                gap: 1rem;
            }

            .pipe-legend {
                grid-template-columns: 1fr;
            }
        }

        /* Flow Animation */
        .flow-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--flow);
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 8px var(--flow);
        }

        .flow-particle.animate {
            animation: flowMove 2s linear;
        }

        @keyframes flowMove {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.2); }
            100% { opacity: 0; transform: scale(0.8); }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav-header">
        <div class="nav-content">
            <a href="/games.html" class="logo">
                <span>🎮</span>
                <span>ZK Gaming Hub</span>
            </a>
            <div class="nav-links">
                <a href="/games.html" class="nav-link">← Back to Games</a>
                <a href="/index.html" class="nav-link">Home</a>
            </div>
        </div>
    </nav>

    <!-- Animated Background -->
    <div class="circuit-bg"></div>

    <div class="game-container">
        <!-- Header -->
        <div class="game-header">
            <h1 class="game-title">
                <span>🔄</span>
                <span>ZK Flow State</span>
            </h1>
            <p class="game-subtitle">Connect the prover to the verifier through a valid proof path!</p>
        </div>

        <!-- Main Game Board -->
        <div class="game-board-container">
            <div class="level-info">
                <div class="level-stats">
                    <div class="stat-item">
                        <span>📊</span>
                        <span>Level</span>
                        <span class="stat-value" id="levelNumber">1</span>
                    </div>
                    <div class="stat-item">
                        <span>⏱️</span>
                        <span>Time</span>
                        <span class="stat-value" id="timer">00:00</span>
                    </div>
                    <div class="stat-item">
                        <span>🔧</span>
                        <span>Moves</span>
                        <span class="stat-value" id="moves">0</span>
                    </div>
                    <div class="stat-item">
                        <span>⭐</span>
                        <span>Score</span>
                        <span class="stat-value" id="score">0</span>
                    </div>
                </div>
                
                <div class="difficulty-selector">
                    <button class="difficulty-btn active" onclick="setDifficulty('easy')">Easy</button>
                    <button class="difficulty-btn" onclick="setDifficulty('medium')">Medium</button>
                    <button class="difficulty-btn" onclick="setDifficulty('hard')">Hard</button>
                </div>
            </div>

            <div class="status-display waiting" id="statusDisplay">
                <div class="status-message" id="statusMessage">Connect the prover to the verifier!</div>
                <div class="proof-status" id="proofStatus">Click tiles to place and rotate pipes</div>
            </div>

            <div class="game-board" id="gameBoard" style="--board-size: 6;"></div>

            <div class="control-panel">
                <button class="btn btn-secondary" onclick="showHint()">
                    <span>💡</span>
                    <span>Hint</span>
                </button>
                <button class="btn btn-secondary" onclick="resetLevel()">
                    <span>🔄</span>
                    <span>Reset</span>
                </button>
                <button class="btn btn-primary" onclick="nextLevel()" id="nextBtn" style="display: none;">
                    <span>Next Level</span>
                    <span>→</span>
                </button>
            </div>
        </div>

        <!-- Side Panel -->
        <div class="side-panel">
            <!-- Instructions -->
            <div class="info-card">
                <h3>🎯 How to Play</h3>
                <p style="color: var(--text-dim); margin-bottom: 1rem; line-height: 1.5;">
                    Connect the <span style="color: var(--prover);">Prover</span> to the 
                    <span style="color: var(--verifier);">Verifier</span> using pipe segments. 
                    Click empty tiles to place pipes, click existing pipes to rotate them.
                </p>
                
                <div class="pipe-legend">
                    <div class="pipe-item">
                        <svg class="pipe-icon" viewBox="0 0 24 24">
                            <line x1="12" y1="2" x2="12" y2="22" stroke="currentColor" stroke-width="3"/>
                        </svg>
                        <span>Straight</span>
                    </div>
                    <div class="pipe-item">
                        <svg class="pipe-icon" viewBox="0 0 24 24">
                            <path d="M12 2 V12 H22" fill="none" stroke="currentColor" stroke-width="3"/>
                        </svg>
                        <span>Curve</span>
                    </div>
                    <div class="pipe-item">
                        <svg class="pipe-icon" viewBox="0 0 24 24">
                            <path d="M2 12 L12 2 L12 12 L22 12" fill="none" stroke="currentColor" stroke-width="3"/>
                        </svg>
                        <span>T-Junction</span>
                    </div>
                    <div class="pipe-item">
                        <svg class="pipe-icon" viewBox="0 0 24 24">
                            <line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="3"/>
                            <line x1="12" y1="2" x2="12" y2="22" stroke="currentColor" stroke-width="3"/>
                        </svg>
                        <span>Cross</span>
                    </div>
                </div>
            </div>

            <!-- ZK Concept -->
            <div class="info-card">
                <h3>🔐 ZK Concept</h3>
                <p style="color: var(--text-dim); font-size: 0.9rem; line-height: 1.5;">
                    This game represents how Zero-Knowledge proofs flow from a prover to a verifier. 
                    The path must be complete and valid, just like a ZK proof circuit!
                </p>
                
                <div style="margin-top: 1rem; padding: 1rem; background: var(--dark-card); border-radius: 0.5rem;">
                    <div style="font-size: 0.875rem; color: var(--text-dim);">
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: var(--prover);">●</span> Prover: Has the secret knowledge
                        </div>
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: var(--flow);">●</span> Proof Path: The ZK circuit
                        </div>
                        <div>
                            <span style="color: var(--verifier);">●</span> Verifier: Confirms validity
                        </div>
                    </div>
                </div>
            </div>

            <!-- Progress -->
            <div class="info-card">
                <h3>📈 Progress</h3>
                <div style="margin-bottom: 1rem;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                        <span style="font-size: 0.9rem;">Level Progress</span>
                        <span style="font-size: 0.9rem; color: var(--primary);" id="progressText">0%</span>
                    </div>
                    <div style="background: var(--dark-card); height: 8px; border-radius: 4px; overflow: hidden;">
                        <div id="progressBar" style="height: 100%; background: linear-gradient(90deg, var(--primary), var(--secondary)); width: 0%; transition: width 0.3s;"></div>
                    </div>
                </div>
                
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid var(--border);">
                    <span style="color: var(--text-dim);">Levels Completed</span>
                    <span style="font-weight: 600; color: var(--primary);" id="levelsCompleted">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                    <span style="color: var(--text-dim);">Best Time</span>
                    <span style="font-weight: 600; color: var(--accent);" id="bestTime">--:--</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Success Modal -->
    <div class="modal" id="successModal">
        <div class="modal-content">
            <div style="font-size: 4rem; margin-bottom: 1rem;">🎉</div>
            <h2 style="font-size: 2rem; margin-bottom: 1rem;">Level Complete!</h2>
            <p style="color: var(--text-dim); margin-bottom: 2rem;">
                You've successfully connected the proof path!
            </p>
            
            <div style="background: var(--dark); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; text-align: left;">
                    <div>
                        <div style="color: var(--text-dim); font-size: 0.875rem;">Time</div>
                        <div style="font-size: 1.5rem; color: var(--primary);" id="modalTime">00:00</div>
                    </div>
                    <div>
                        <div style="color: var(--text-dim); font-size: 0.875rem;">Moves</div>
                        <div style="font-size: 1.5rem; color: var(--accent);" id="modalMoves">0</div>
                    </div>
                    <div>
                        <div style="color: var(--text-dim); font-size: 0.875rem;">Efficiency</div>
                        <div style="font-size: 1.5rem; color: var(--warning);" id="modalEfficiency">100%</div>
                    </div>
                    <div>
                        <div style="color: var(--text-dim); font-size: 0.875rem;">Points</div>
                        <div style="font-size: 1.5rem; color: var(--primary);" id="modalPoints">0</div>
                    </div>
                </div>
            </div>

            <button class="btn btn-primary" onclick="continueToNext()" style="width: 100%;">
                <span>Continue</span>
                <span>→</span>
            </button>
        </div>
    </div>

    <script>
        // Game State
        let gameState = {
            level: 1,
            difficulty: 'easy',
            boardSize: 6,
            board: [],
            proverPos: { r: 0, c: 0 },
            verifierPos: { r: 5, c: 5 },
            moves: 0,
            startTime: Date.now(),
            score: 0,
            isComplete: false,
            flowPath: [],
            levelsCompleted: parseInt(localStorage.getItem('zk-flow-levels') || '0'),
            bestTime: localStorage.getItem('zk-flow-best-time') || null
        };

        // Tile types and their connection patterns
        const tileTypes = {
            empty: { connections: [], rotatable: false },
            straight: { connections: [[0,2], [1,3]], rotatable: true },
            curve: { connections: [[0,1], [1,2], [2,3], [3,0]], rotatable: true },
            tjunction: { connections: [[0,1,2], [1,2,3], [2,3,0], [3,0,1]], rotatable: true },
            cross: { connections: [[0,1,2,3]], rotatable: false },
            prover: { connections: [[1]], rotatable: false },
            verifier: { connections: [[3]], rotatable: false }
        };

        // Direction mappings: 0=up, 1=right, 2=down, 3=left
        const directions = [[-1,0], [0,1], [1,0], [0,-1]];

        let timerInterval;

        // Initialize game
        document.addEventListener('DOMContentLoaded', () => {
            updateStats();
            setupLevel();
            startTimer();
        });

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function setupLevel() {
            const size = getDifficultySettings().boardSize;
            gameState.boardSize = size;
            gameState.board = Array(size).fill().map(() => Array(size).fill().map(() => ({ type: 'empty', rotation: 0 })));
            
            // Set prover and verifier positions based on level
            if (gameState.level <= 3) {
                gameState.proverPos = { r: 0, c: 0 };
                gameState.verifierPos = { r: size-1, c: size-1 };
            } else {
                // More complex positioning for higher levels
                gameState.proverPos = { r: Math.floor(Math.random() * size), c: 0 };
                gameState.verifierPos = { r: Math.floor(Math.random() * size), c: size-1 };
            }
            
            // Place prover and verifier
            gameState.board[gameState.proverPos.r][gameState.proverPos.c] = { type: 'prover', rotation: 0 };
            gameState.board[gameState.verifierPos.r][gameState.verifierPos.c] = { type: 'verifier', rotation: 0 };
            
            // Add some pre-placed pipes for easier levels
            if (gameState.level <= 2) {
                addHelpfulPipes();
            }
            
            gameState.moves = 0;
            gameState.startTime = Date.now();
            gameState.isComplete = false;
            
            renderBoard();
            updateStats();
            updateStatus();
        }

        function getDifficultySettings() {
            const settings = {
                easy: { boardSize: 5, helpfulPipes: 3 },
                medium: { boardSize: 6, helpfulPipes: 2 },
                hard: { boardSize: 7, helpfulPipes: 1 }
            };
            return settings[gameState.difficulty];
        }

        function addHelpfulPipes() {
            const settings = getDifficultySettings();
            const { boardSize } = gameState;
            
            // Add a few strategic pipes
            for (let i = 0; i < settings.helpfulPipes; i++) {
                let r, c;
                do {
                    r = Math.floor(Math.random() * boardSize);
                    c = Math.floor(Math.random() * boardSize);
                } while (gameState.board[r][c].type !== 'empty');
                
                const types = ['straight', 'curve'];
                const type = types[Math.floor(Math.random() * types.length)];
                gameState.board[r][c] = { 
                    type, 
                    rotation: Math.floor(Math.random() * 4),
                    locked: true 
                };
            }
        }

        function renderBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            board.style.setProperty('--board-size', gameState.boardSize);
            
            for (let r = 0; r < gameState.boardSize; r++) {
                for (let c = 0; c < gameState.boardSize; c++) {
                    const tile = gameState.board[r][c];
                    const div = document.createElement('div');
                    div.className = 'tile';
                    div.dataset.row = r;
                    div.dataset.col = c;
                    
                    if (tile.type === 'prover') {
                        div.classList.add('prover');
                        div.innerHTML = `
                            <svg class="pipe-svg" viewBox="0 0 100 100">
                                <circle cx="50" cy="50" r="35" fill="currentColor"/>
                                <circle cx="50" cy="50" r="20" fill="white"/>
                                <text x="50" y="58" text-anchor="middle" font-size="20" fill="currentColor">P</text>
                            </svg>
                        `;
                    } else if (tile.type === 'verifier') {
                        div.classList.add('verifier');
                        div.innerHTML = `
                            <svg class="pipe-svg" viewBox="0 0 100 100">
                                <rect x="15" y="15" width="70" height="70" rx="10" fill="currentColor"/>
                                <rect x="30" y="30" width="40" height="40" rx="5" fill="white"/>
                                <text x="50" y="58" text-anchor="middle" font-size="20" fill="currentColor">V</text>
                            </svg>
                        `;
                    } else if (tile.type !== 'empty') {
                        div.innerHTML = createPipeSVG(tile.type, tile.rotation);
                    }
                    
                    if (tile.locked) {
                        div.classList.add('locked');
                    }
                    
                    div.addEventListener('click', () => onTileClick(r, c));
                    board.appendChild(div);
                }
            }
            
            // Highlight flow path
            setTimeout(() => updateFlowVisualization(), 100);
        }

        function createPipeSVG(type, rotation) {
            const transform = `transform: rotate(${rotation * 90}deg)`;
            
            switch (type) {
                case 'straight':
                    return `
                        <svg class="pipe-svg" viewBox="0 0 100 100" style="${transform}">
                            <line x1="50" y1="10" x2="50" y2="90" class="pipe-straight"/>
                        </svg>
                    `;
                case 'curve':
                    return `
                        <svg class="pipe-svg" viewBox="0 0 100 100" style="${transform}">
                            <path d="M50 10 V50 H90" class="pipe-curve"/>
                        </svg>
                    `;
                case 'tjunction':
                    return `
                        <svg class="pipe-svg" viewBox="0 0 100 100" style="${transform}">
                            <line x1="50" y1="10" x2="50" y2="90" class="pipe-straight"/>
                            <line x1="10" y1="50" x2="50" y2="50" class="pipe-straight"/>
                        </svg>
                    `;
                case 'cross':
                    return `
                        <svg class="pipe-svg" viewBox="0 0 100 100">
                            <line x1="50" y1="10" x2="50" y2="90" class="pipe-straight"/>
                            <line x1="10" y1="50" x2="90" y2="50" class="pipe-straight"/>
                        </svg>
                    `;
                default:
                    return '';
            }
        }

        function onTileClick(r, c) {
            if (gameState.isComplete) return;
            
            const tile = gameState.board[r][c];
            if (tile.type === 'prover' || tile.type === 'verifier' || tile.locked) return;
            
            if (tile.type === 'empty') {
                // Cycle through pipe types
                const types = ['straight', 'curve', 'tjunction'];
                tile.type = types[0];
                tile.rotation = 0;
            } else {
                // Rotate existing pipe
                tile.rotation = (tile.rotation + 1) % 4;
            }
            
            gameState.moves++;
            updateStats();
            renderBoard();
            
            // Check for completion after a short delay
            setTimeout(() => {
                if (checkPathComplete()) {
                    levelComplete();
                }
            }, 100);
        }

        function checkPathComplete() {
            // Find path from prover to verifier using BFS
            const visited = Array(gameState.boardSize).fill().map(() => Array(gameState.boardSize).fill(false));
            const queue = [{ r: gameState.proverPos.r, c: gameState.proverPos.c, path: [] }];
            
            while (queue.length > 0) {
                const { r, c, path } = queue.shift();
                
                if (visited[r][c]) continue;
                visited[r][c] = true;
                
                const newPath = [...path, { r, c }];
                
                // Check if we reached the verifier
                if (r === gameState.verifierPos.r && c === gameState.verifierPos.c) {
                    gameState.flowPath = newPath;
                    return true;
                }
                
                // Get connections from current tile
                const tile = gameState.board[r][c];
                const connections = getTileConnections(tile);
                
                for (const dir of connections) {
                    const nr = r + directions[dir][0];
                    const nc = c + directions[dir][1];
                    
                    if (nr < 0 || nr >= gameState.boardSize || nc < 0 || nc >= gameState.boardSize) continue;
                    if (visited[nr][nc]) continue;
                    
                    // Check if the next tile can connect back
                    const nextTile = gameState.board[nr][nc];
                    const nextConnections = getTileConnections(nextTile);
                    const oppositeDir = (dir + 2) % 4;
                    
                    if (nextConnections.includes(oppositeDir)) {
                        queue.push({ r: nr, c: nc, path: newPath });
                    }
                }
            }
            
            gameState.flowPath = [];
            return false;
        }

        function getTileConnections(tile) {
            if (!tileTypes[tile.type]) return [];
            
            const baseConnections = tileTypes[tile.type].connections;
            if (!baseConnections || baseConnections.length === 0) return [];
            
            // Handle rotation
            if (tile.type === 'straight') {
                return tile.rotation % 2 === 0 ? [0, 2] : [1, 3];
            } else if (tile.type === 'curve') {
                const base = [0, 1];
                return base.map(dir => (dir + tile.rotation) % 4);
            } else if (tile.type === 'tjunction') {
                const base = [0, 1, 2];
                return base.map(dir => (dir + tile.rotation) % 4);
            } else if (tile.type === 'cross') {
                return [0, 1, 2, 3];
            } else if (tile.type === 'prover') {
                return [1]; // Always points right
            } else if (tile.type === 'verifier') {
                return [3]; // Always accepts from left
            }
            
            return [];
        }

        function updateFlowVisualization() {
            // Remove previous flow highlighting
            document.querySelectorAll('.tile').forEach(tile => {
                tile.classList.remove('flowing');
            });
            
            // Highlight flow path if complete
            if (gameState.flowPath.length > 0) {
                gameState.flowPath.forEach(({ r, c }) => {
                    const tile = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (tile) {
                        tile.classList.add('flowing');
                    }
                });
                
                // Create flow particles
                createFlowParticles();
            }
        }

        function createFlowParticles() {
            if (gameState.flowPath.length < 2) return;
            
            const board = document.getElementById('gameBoard');
            const boardRect = board.getBoundingClientRect();
            const tileSize = boardRect.width / gameState.boardSize;
            
            gameState.flowPath.forEach((pos, index) => {
                if (index === gameState.flowPath.length - 1) return;
                
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.className = 'flow-particle animate';
                    
                    const startX = pos.c * tileSize + tileSize / 2;
                    const startY = pos.r * tileSize + tileSize / 2;
                    
                    particle.style.left = startX + 'px';
                    particle.style.top = startY + 'px';
                    
                    board.appendChild(particle);
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.remove();
                        }
                    }, 2000);
                }, index * 200);
            });
        }

        function levelComplete() {
            gameState.isComplete = true;
            
            const timeElapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
            const efficiency = Math.max(20, 100 - gameState.moves * 2);
            const points = calculatePoints(timeElapsed, efficiency);
            
            gameState.score += points;
            
            // Update best time
            if (!gameState.bestTime || timeElapsed < parseInt(gameState.bestTime)) {
                gameState.bestTime = timeElapsed;
                localStorage.setItem('zk-flow-best-time', timeElapsed.toString());
            }
            
            // Update completed levels
            if (gameState.level > gameState.levelsCompleted) {
                gameState.levelsCompleted = gameState.level;
                localStorage.setItem('zk-flow-levels', gameState.levelsCompleted.toString());
            }
            
            updateStats();
            updateStatus(true);
            
            // Show success modal
            setTimeout(() => {
                showSuccessModal(timeElapsed, efficiency, points);
            }, 1000);
        }

        function calculatePoints(time, efficiency) {
            let points = 100; // Base points
            
            // Time bonus
            if (time < 30) points += 100;
            else if (time < 60) points += 50;
            else if (time < 120) points += 25;
            
            // Efficiency bonus
            points += efficiency;
            
            // Level bonus
            points += gameState.level * 10;
            
            return points;
        }

        function showSuccessModal(time, efficiency, points) {
            const minutes = Math.floor(time / 60);
            const seconds = time % 60;
            
            document.getElementById('modalTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('modalMoves').textContent = gameState.moves;
            document.getElementById('modalEfficiency').textContent = efficiency + '%';
            document.getElementById('modalPoints').textContent = points;
            
            document.getElementById('successModal').classList.add('show');
        }

        function updateStats() {
            document.getElementById('levelNumber').textContent = gameState.level;
            document.getElementById('moves').textContent = gameState.moves;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('levelsCompleted').textContent = gameState.levelsCompleted;
            
            if (gameState.bestTime) {
                const minutes = Math.floor(gameState.bestTime / 60);
                const seconds = gameState.bestTime % 60;
                document.getElementById('bestTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Update progress
            const progress = gameState.isComplete ? 100 : Math.min(90, (gameState.moves / 20) * 100);
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('progressText').textContent = Math.round(progress) + '%';
        }

        function updateStatus(success = false) {
            const statusDisplay = document.getElementById('statusDisplay');
            const statusMessage = document.getElementById('statusMessage');
            const proofStatus = document.getElementById('proofStatus');
            
            if (success) {
                statusDisplay.className = 'status-display success';
                statusMessage.textContent = 'Proof path established!';
                proofStatus.textContent = 'Zero-Knowledge proof successfully verified';
            } else if (gameState.flowPath.length > 0) {
                statusDisplay.className = 'status-display success';
                statusMessage.textContent = 'Path connected!';
                proofStatus.textContent = 'Generating proof verification...';
            } else {
                statusDisplay.className = 'status-display waiting';
                statusMessage.textContent = 'Connect the prover to the verifier!';
                proofStatus.textContent = 'Click tiles to place and rotate pipes';
            }
        }

        function setDifficulty(level) {
            gameState.difficulty = level;
            
            // Update UI
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = Array.from(document.querySelectorAll('.difficulty-btn'))
                .find(btn => btn.textContent.toLowerCase() === level);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            
            setupLevel();
        }

        function showHint() {
            // Highlight a possible next move
            const { r, c } = findBestMove();
            if (r !== -1 && c !== -1) {
                const tile = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (tile) {
                    tile.style.background = 'rgba(245, 158, 11, 0.3)';
                    tile.style.borderColor = 'var(--warning)';
                    
                    setTimeout(() => {
                        tile.style.background = '';
                        tile.style.borderColor = '';
                    }, 2000);
                }
            }
        }

        function findBestMove() {
            // Simple heuristic: find empty tile closest to the direct path
            const prover = gameState.proverPos;
            const verifier = gameState.verifierPos;
            
            let bestTile = { r: -1, c: -1 };
            let minDistance = Infinity;
            
            for (let r = 0; r < gameState.boardSize; r++) {
                for (let c = 0; c < gameState.boardSize; c++) {
                    if (gameState.board[r][c].type === 'empty') {
                        // Calculate distance to ideal path
                        const distToProver = Math.abs(r - prover.r) + Math.abs(c - prover.c);
                        const distToVerifier = Math.abs(r - verifier.r) + Math.abs(c - verifier.c);
                        const totalDist = distToProver + distToVerifier;
                        
                        if (totalDist < minDistance) {
                            minDistance = totalDist;
                            bestTile = { r, c };
                        }
                    }
                }
            }
            
            return bestTile;
        }

        function resetLevel() {
            setupLevel();
        }

        function nextLevel() {
            gameState.level++;
            setupLevel();
        }

        function continueToNext() {
            document.getElementById('successModal').classList.remove('show');
            nextLevel();
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.classList.remove('show');
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                resetLevel();
            } else if (e.key === 'h' || e.key === 'H') {
                showHint();
            } else if (e.key === 'n' || e.key === 'N') {
                if (gameState.isComplete) {
                    nextLevel();
                }
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
        });

        // Enhanced error handling
        window.addEventListener('error', (e) => {
            console.error('ZK Flow State error:', e.error);
            try {
                if (!gameState.board || gameState.board.length === 0) {
                    setupLevel();
                }
            } catch (resetError) {
                console.error('Failed to reset game after error:', resetError);
            }
        });

        console.log('🔄 ZK Flow State loaded successfully!');
        console.log('Controls: Click to place/rotate pipes, R to reset, H for hint, N for next level');
    </script>
</body>
</html>